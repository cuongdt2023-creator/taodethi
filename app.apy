import streamlit as st
import re
import random
import zipfile
import io
from xml.dom import minidom

# ==================== C·∫§U H√åNH & GIAO DI·ªÜN ====================

st.set_page_config(page_title="T·∫°o ƒê·ªÅ Theo Ma Tr·∫≠n - AIOMT Premium", page_icon="üìù", layout="wide")

st.markdown("""
<style>
    .main-header h1 { color: #0d9488; text-align: center; }
    .stButton > button { background-color: #0d9488; color: white; font-weight: bold; }
    .metric-card { background: #f0fdfa; padding: 10px; border-radius: 8px; border: 1px solid #ccfbf1; text-align: center; }
</style>
""", unsafe_allow_html=True)

W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"

# ==================== CORE LOGIC X·ª¨ L√ù XML ====================

def get_text(block):
    """L·∫•y text th√¥ t·ª´ block XML ƒë·ªÉ ph√¢n t√≠ch"""
    texts = []
    t_nodes = block.getElementsByTagNameNS(W_NS, "t")
    for t in t_nodes:
        if t.firstChild and t.firstChild.nodeValue:
            texts.append(t.firstChild.nodeValue)
    return "".join(texts).strip()

def detect_difficulty(text):
    """Ph√°t hi·ªán ƒë·ªô kh√≥ d·ª±a tr√™n tag #NB, #TH, #VD, #VDC"""
    text_upper = text.upper()
    if "#NB" in text_upper: return "NB"
    if "#TH" in text_upper: return "TH"
    if "#VDC" in text_upper: return "VDC" # Check VDC tr∆∞·ªõc VD ƒë·ªÉ tr√°nh nh·∫ßm
    if "#VD" in text_upper: return "VD"
    return "NB" # M·∫∑c ƒë·ªãnh l√† Nh·∫≠n bi·∫øt n·∫øu kh√¥ng ghi

def remove_tags_from_block(block):
    """X√≥a c√°c tag #NB, #TH... kh·ªèi file k·∫øt qu·∫£ ƒë·ªÉ ƒë·ªÅ thi s·∫°ch ƒë·∫πp"""
    t_nodes = block.getElementsByTagNameNS(W_NS, "t")
    for t in t_nodes:
        if t.firstChild and t.firstChild.nodeValue:
            val = t.firstChild.nodeValue
            # Regex x√≥a c√°c tag d·∫°ng #NB, #TH, #VD, #VDC (kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng)
            new_val = re.sub(r'#(NB|TH|VDC|VD)\b', '', val, flags=re.IGNORECASE)
            if new_val != val:
                t.firstChild.nodeValue = new_val

def parse_bank(blocks):
    """Ph√¢n t√≠ch ng√¢n h√†ng c√¢u h·ªèi th√†nh c·∫•u tr√∫c d·ªØ li·ªáu"""
    structure = {
        "PHAN1": {"NB": [], "TH": [], "VD": [], "VDC": []},
        "PHAN2": {"NB": [], "TH": [], "VD": [], "VDC": []},
        "PHAN3": {"NB": [], "TH": [], "VD": [], "VDC": []}
    }
    
    current_part = "PHAN1" # M·∫∑c ƒë·ªãnh b·∫Øt ƒë·∫ßu l√† ph·∫ßn 1
    current_q_blocks = []
    current_diff = "NB"
    
    # T√¨m v·ªã tr√≠ c√°c ph·∫ßn
    part_indices = {}
    for i, block in enumerate(blocks):
        txt = get_text(block).upper()
        if "PH·∫¶N 1" in txt: current_part = "PHAN1"
        elif "PH·∫¶N 2" in txt: current_part = "PHAN2"
        elif "PH·∫¶N 3" in txt: current_part = "PHAN3"
        
        # Nh·∫≠n di·ªán b·∫Øt ƒë·∫ßu c√¢u h·ªèi m·ªõi "C√¢u X."
        if re.match(r'^C√¢u\s*\d+', get_text(block), re.IGNORECASE):
            # L∆∞u c√¢u h·ªèi tr∆∞·ªõc ƒë√≥ n·∫øu c√≥
            if current_q_blocks:
                structure[prev_part][current_diff].append(current_q_blocks)
            
            # Reset cho c√¢u m·ªõi
            current_q_blocks = [block]
            current_diff = detect_difficulty(get_text(block))
            prev_part = current_part # L∆∞u l·∫°i ph·∫ßn c·ªßa c√¢u n√†y
        else:
            if current_q_blocks: # N·∫øu ƒëang trong 1 c√¢u h·ªèi, add block v√†o
                current_q_blocks.append(block)
    
    # L∆∞u c√¢u cu·ªëi c√πng
    if current_q_blocks:
        structure[prev_part][current_diff].append(current_q_blocks)
        
    return structure

def select_questions(bank, config):
    """Ch·ªçn c√¢u h·ªèi ng·∫´u nhi√™n theo c·∫•u h√¨nh"""
    selected_blocks = []
    
    # Th·ª© t·ª± ph·∫ßn ƒë·ªÉ in ra
    parts = ["PHAN1", "PHAN2", "PHAN3"]
    part_titles = {
        "PHAN1": "PH·∫¶N 1. C√¢u tr·∫Øc nghi·ªám nhi·ªÅu ph∆∞∆°ng √°n l·ª±a ch·ªçn.",
        "PHAN2": "PH·∫¶N 2. C√¢u tr·∫Øc nghi·ªám ƒë√∫ng sai.",
        "PHAN3": "PH·∫¶N 3. C√¢u tr·∫Øc nghi·ªám tr·∫£ l·ªùi ng·∫Øn."
    }
    
    msg_log = []
    
    for part in parts:
        # Th√™m ti√™u ƒë·ªÅ ph·∫ßn (T·∫°o block XML gi·∫£ l·∫≠p ho·∫∑c ch·ªâ l·∫•y c√°c c√¢u h·ªèi)
        # ·ªû ƒë√¢y ta gi·∫£ ƒë·ªãnh ng∆∞·ªùi d√πng mu·ªën gi·ªØ format, ta s·∫Ω kh√¥ng t·ª± t·∫°o ti√™u ƒë·ªÅ XML ph·ª©c t·∫°p
        # M√† s·∫Ω d·ª±a v√†o vi·ªác ng∆∞·ªùi d√πng t·ª± ƒë·ªãnh d·∫°ng ti√™u ƒë·ªÅ trong file output ho·∫∑c
        # Ta ch·∫•p nh·∫≠n kh√¥ng c√≥ ti√™u ƒë·ªÅ ph·∫ßn n·∫øu t·∫°o m·ªõi ho√†n to√†n.
        # Tuy nhi√™n, ƒë·ªÉ ƒë∆°n gi·∫£n, ta ch·ªâ tr·∫£ v·ªÅ danh s√°ch c√°c c√¢u h·ªèi ƒë√£ ch·ªçn.
        
        req = config[part]
        part_qs = []
        
        for diff in ["NB", "TH", "VD", "VDC"]:
            count_needed = req[diff]
            available = bank[part][diff]
            
            if len(available) < count_needed:
                msg_log.append(f"‚ö†Ô∏è {part} - {diff}: C·∫ßn {count_needed} c√¢u, ch·ªâ c√≥ {len(available)} c√¢u.")
                selected = available # L·∫•y h·∫øt
            else:
                selected = random.sample(available, count_needed)
            
            part_qs.extend(selected)
            
        # Tr·ªôn ng·∫´u nhi√™n th·ª© t·ª± c√¢u trong ph·∫ßn ƒë√≥
        random.shuffle(part_qs)
        
        # ƒê√°nh l·∫°i s·ªë th·ª© t·ª± c√¢u h·ªèi v√† l√†m s·∫°ch tag
        start_idx = 1
        if part == "PHAN2": start_idx = 1 # Reset theo t·ª´ng ph·∫ßn ho·∫∑c n·ªëi ti·∫øp t√πy logic
        if part == "PHAN3": start_idx = 1
        # N·∫øu mu·ªën n·ªëi ti·∫øp:
        # if part == "PHAN2": start_idx = len(config["PHAN1"]["total"]) + 1 ...
        
        # Nh∆∞ng code g·ªëc c·ªßa b·∫°n ƒëang reset ho·∫∑c n·ªëi ti·∫øp? 
        # Theo chu·∫©n ƒë·ªÅ m·ªõi 2025: Ph·∫ßn 2 v√† 3 reset l·∫°i t·ª´ C√¢u 1 hay n·ªëi ti·∫øp?
        # Th∆∞·ªùng l√† C√¢u 1 ƒë·∫øn 12, Ph·∫ßn 2 l√† C√¢u 1 ƒë·∫øn 4.
        # ·ªû ƒë√¢y t√¥i s·∫Ω ƒë·ªÉ logic ƒë√°nh s·ªë l·∫°i (Relabel)
        
        final_part_blocks = []
        for idx, q_blocks in enumerate(part_qs):
            # C·∫≠p nh·∫≠t "C√¢u X."
            first_blk = q_blocks[0]
            update_question_label(first_blk, f"C√¢u {idx + 1}.")
            remove_tags_from_block(first_blk) # X√≥a tag #NB...
            
            final_part_blocks.extend(q_blocks)
            
        selected_blocks.extend(final_part_blocks)
        
    return selected_blocks, msg_log

def update_question_label(paragraph, new_label):
    """C·∫≠p nh·∫≠t nh√£n C√¢u X. gi·ªØ nguy√™n ƒë·ªãnh d·∫°ng"""
    t_nodes = paragraph.getElementsByTagNameNS(W_NS, "t")
    for t in t_nodes:
        if t.firstChild and t.firstChild.nodeValue:
            txt = t.firstChild.nodeValue
            # Regex t√¨m "C√¢u ... ."
            m = re.match(r'^(\s*)(C√¢u\s*\d+)(\.)?', txt, re.IGNORECASE)
            if m:
                # Thay th·∫ø
                t.firstChild.nodeValue = re.sub(r'^(\s*)(C√¢u\s*\d+)(\.)?', f"{m.group(1)}{new_label}", txt)
                break

def generate_exam(file_bytes, config):
    """H√†m ch√≠nh t·∫°o ƒë·ªÅ"""
    input_buffer = io.BytesIO(file_bytes)
    with zipfile.ZipFile(input_buffer, 'r') as zin:
        doc_xml = zin.read("word/document.xml").decode('utf-8')
        dom = minidom.parseString(doc_xml)
        body = dom.getElementsByTagNameNS(W_NS, "body")[0]
        
        # 1. L·∫•y t·∫•t c·∫£ block
        all_blocks = []
        for child in list(body.childNodes):
            if child.nodeType == child.ELEMENT_NODE:
                if child.localName in ["p", "tbl"]:
                    all_blocks.append(child)
                body.removeChild(child) # X√≥a kh·ªèi c√¢y DOM ƒë·ªÉ t√≠ n·ªØa add l·∫°i c√°i ƒë√£ ch·ªçn
        
        # 2. Ph√¢n lo·∫°i c√¢u h·ªèi t·ª´ file g·ªëc
        bank = parse_bank(all_blocks)
        
        # 3. Ch·ªçn c√¢u h·ªèi theo ma tr·∫≠n
        selected_blocks, log = select_questions(bank, config)
        
        # 4. Th√™m l·∫°i v√†o body
        # Th√™m ti√™u ƒë·ªÅ (n·∫øu mu·ªën gi·ªØ header file g·ªëc th√¨ c·∫ßn logic ph·ª©c t·∫°p h∆°n, 
        # ·ªü ƒë√¢y ta ch·ªâ ch√®n c√¢u h·ªèi ƒë√£ ch·ªçn)
        for blk in selected_blocks:
            body.appendChild(blk)
            
        # Th√™m Section Properties (Trang in) n·∫øu c√≥ ·ªü cu·ªëi
        sectPrs = dom.getElementsByTagNameNS(W_NS, "sectPr")
        if sectPrs:
             body.appendChild(sectPrs[-1])

        new_xml = dom.toxml()
        
        output_buffer = io.BytesIO()
        with zipfile.ZipFile(output_buffer, 'w', zipfile.ZIP_DEFLATED) as zout:
            for item in zin.infolist():
                if item.filename == "word/document.xml":
                    zout.writestr(item, new_xml.encode('utf-8'))
                else:
                    zout.writestr(item, zin.read(item.filename))
                    
    return output_buffer.getvalue(), log

# ==================== UI GIAO DI·ªÜN ====================

st.markdown("<div class='main-header'><h1>üß© T·∫°o ƒê·ªÅ Thi Theo Ma Tr·∫≠n (2025)</h1></div>", unsafe_allow_html=True)

col_info, col_up = st.columns([1, 1])

with col_info:
    st.info("""
    **H∆∞·ªõng d·∫´n chu·∫©n b·ªã file ng√¢n h√†ng:**
    1. So·∫°n th·∫£o b√¨nh th∆∞·ªùng, chia r√µ **PH·∫¶N 1**, **PH·∫¶N 2**, **PH·∫¶N 3**.
    2. G√°n tag ƒë·ªô kh√≥ v√†o d√≤ng ch·ª©a "C√¢u X." ho·∫∑c ƒë·∫ßu c√¢u h·ªèi:
       - `#NB`: Nh·∫≠n bi·∫øt
       - `#TH`: Th√¥ng hi·ªÉu
       - `#VD`: V·∫≠n d·ª•ng
       - `#VDC`: V·∫≠n d·ª•ng cao
    3. Upload file v√†o b√™n ph·∫£i v√† c·∫•u h√¨nh ma tr·∫≠n.
    """)

with col_up:
    uploaded_file = st.file_uploader("Upload Ng√¢n h√†ng c√¢u h·ªèi (.docx)", type="docx")

if uploaded_file:
    st.divider()
    st.subheader("‚öôÔ∏è C·∫•u h√¨nh Ma tr·∫≠n ƒë·ªÅ")
    
    # C·∫•u h√¨nh Ph·∫ßn 1
    st.markdown("### üîπ PH·∫¶N 1: Tr·∫Øc nghi·ªám (12 c√¢u)")
    c1, c2, c3, c4 = st.columns(4)
    p1_nb = c1.number_input("P1-NB (C√¢u)", min_value=0, value=4)
    p1_th = c2.number_input("P1-TH (C√¢u)", min_value=0, value=4)
    p1_vd = c3.number_input("P1-VD (C√¢u)", min_value=0, value=2)
    p1_vdc = c4.number_input("P1-VDC (C√¢u)", min_value=0, value=2)
    st.caption(f"T·ªïng Ph·∫ßn 1: {p1_nb+p1_th+p1_vd+p1_vdc} c√¢u (Chu·∫©n: 12)")

    # C·∫•u h√¨nh Ph·∫ßn 2
    st.markdown("### üîπ PH·∫¶N 2: ƒê√∫ng/Sai (4 c√¢u)")
    c1, c2, c3, c4 = st.columns(4)
    p2_nb = c1.number_input("P2-NB (C√¢u)", min_value=0, value=1)
    p2_th = c2.number_input("P2-TH (C√¢u)", min_value=0, value=1)
    p2_vd = c3.number_input("P2-VD (C√¢u)", min_value=0, value=1)
    p2_vdc = c4.number_input("P2-VDC (C√¢u)", min_value=0, value=1)
    st.caption(f"T·ªïng Ph·∫ßn 2: {p2_nb+p2_th+p2_vd+p2_vdc} c√¢u (Chu·∫©n: 4)")

    # C·∫•u h√¨nh Ph·∫ßn 3
    st.markdown("### üîπ PH·∫¶N 3: Tr·∫£ l·ªùi ng·∫Øn (6 c√¢u)")
    c1, c2, c3, c4 = st.columns(4)
    p3_nb = c1.number_input("P3-NB (C√¢u)", min_value=0, value=2)
    p3_th = c2.number_input("P3-TH (C√¢u)", min_value=0, value=2)
    p3_vd = c3.number_input("P3-VD (C√¢u)", min_value=0, value=1)
    p3_vdc = c4.number_input("P3-VDC (C√¢u)", min_value=0, value=1)
    st.caption(f"T·ªïng Ph·∫ßn 3: {p3_nb+p3_th+p3_vd+p3_vdc} c√¢u (Chu·∫©n: 6)")

    # N√∫t t·∫°o ƒë·ªÅ
    if st.button("üöÄ T·∫°o ƒê·ªÅ Ngay", use_container_width=True):
        config = {
            "PHAN1": {"NB": p1_nb, "TH": p1_th, "VD": p1_vd, "VDC": p1_vdc},
            "PHAN2": {"NB": p2_nb, "TH": p2_th, "VD": p2_vd, "VDC": p2_vdc},
            "PHAN3": {"NB": p3_nb, "TH": p3_th, "VD": p3_vd, "VDC": p3_vdc},
        }
        
        try:
            with st.spinner("ƒêang ph√¢n t√≠ch ng√¢n h√†ng v√† tr√≠ch xu·∫•t c√¢u h·ªèi..."):
                file_bytes = uploaded_file.read()
                out_bytes, logs = generate_exam(file_bytes, config)
            
            if logs:
                with st.expander("‚ö†Ô∏è C·∫£nh b√°o (Thi·∫øu c√¢u h·ªèi)"):
                    for l in logs:
                        st.warning(l)
            else:
                st.success("‚úÖ T·∫°o ƒë·ªÅ th√†nh c√¥ng! ƒê·ªß s·ªë l∆∞·ª£ng c√¢u h·ªèi y√™u c·∫ßu.")
                
            st.download_button(
                label="üì• T·∫£i ƒë·ªÅ thi v·ªÅ (.docx)",
                data=out_bytes,
                file_name="De_Thi_Ma_Tran.docx",
                mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                use_container_width=True
            )
            
        except Exception as e:
            st.error(f"C√≥ l·ªói x·∫£y ra: {e}")
